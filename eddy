#! /usr/bin/env python3

import gettext
from gettext import gettext as _
import os
import types
import weakref

import gi
gi.require_version('Gdk', '3.0')
gi.require_version('Gtk', '3.0')
gtk_minor_version = 14
from gi.repository import GLib, GObject, Gio, Gdk, Gtk


class MenuItem(Gtk.Button):
    '''
        A button that has a key associated with it and is activated by
        that key.  It goes inside a Menu.
    '''
    def __init__(self, **props):
        super().__init__(**dict(focus_on_click=False, **props))

        self.__grid = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
        self.add(self.__grid)

        self.__label = Gtk.Label(use_underline=True, hexpand=True,
                                 halign=Gtk.Align.START)
        self.__grid.add(self.__label)

        self.__keyval_label = Gtk.Label()
        self.__grid.add(self.__keyval_label)

        self.__grid.show_all()

        self.keyval = None
        self.label = None

    @property
    def keyval(self):
        return self.__keyval
    @keyval.setter
    def keyval(self, keyval):
        if keyval is not None:
            kvs = chr(Gdk.keyval_to_unicode(keyval))
            self.__keyval_label.set_markup(
                '<b> '+GLib.markup_escape_text(kvs)+'</b>')
        else:
            self.__keyval_label.props.label = ''

    @property
    def label(self):
        return self.__label.props.label
    @label.setter
    def label(self, label):
        self.__label.props.label = label


class Menu(Gtk.Grid):
    '''
        A panel with several MenuItems arranged in a keyboard-like
        layout that can be activated by the corresponding keys.
    '''
    # A sequence of sequences of keyvals representing the keys used to
    # activate the MenuItems, organized by location.
    _keyvals = NotImplemented

    def __init__(self, **props):
        super().__init__(**dict(row_homogeneous=True, column_homogeneous=True,
                                hexpand=True, **props))
        if type(self) == Menu:
            raise NotImplementedError('Abstract class')
        self.__items = {}
        for row, row_contents in enumerate(self._keyvals):
            for column in range(len(row_contents)):
                self.__create_item(row, column)

    def __create_item(self, row, column):
        keyval = self._keyvals[row][column]
        item = MenuItem(sensitive=False)
        item.keyval = keyval
        item.show()
        self.attach(item, self.__key_coörds_to_grid_col(row, column), row,
                    4, 1)
        self.__items[keyval] = item

    def __get_item(self, row, column):
        return self.get_child_at(self.__key_coörds_to_grid_col(row, column),
                                 row)

    def bind_key(self, label, callback, row, column):
        item = self.__get_item(row, column)
        item.label = label
        item.props.sensitive = True
        item.__handler_id = item.connect('clicked', callback)

    def unbind_key(self, row, column):
        item = self.__get_item(row, column)
        item.disconnect(item.__handler_id)
        item.props.sensitive = False
        item.label = None
        del item.__handler_id

    def do_key_press_event(self, event):
        return self.key_press(event.keyval)

    def do_key_release_event(self, event):
        return self.key_press(event.keyval)

    @staticmethod
    def __key_coörds_to_grid_col(row, column):
        '''
            Given the coördinates of a key, return the leftmost column
            its button occupies in the grid.
        '''
        return 4*column + row**2 - row//2

    def key_press(self, keyval):
        '''
            Called to indicate a key has been pressed while this menu
            was shown.  This is simpler than using event signals.
        '''
        if keyval in self.__items:
            self.__items[keyval].emit('clicked')


class LMenu(Menu):
    _keyvals = tuple(map(lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
                         (('q', 'w', 'e', 'r', 't'),
                          ('a', 's', 'd', 'f', 'g'),
                          ('z', 'x', 'c', 'v', 'b'))))

    def __init__(self, **props):
        super().__init__(**props)
        spacer = Gtk.Label()
        spacer.show()
        self.attach(spacer, 23, 2, 9, 1)


class RMenu(Menu):
    _keyvals = tuple(map(
        lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
        (('y', 'u', 'i', 'o', 'p', 'bracketleft', 'bracketright'),
         ('h', 'j', 'k', 'l', 'semicolon', 'apostrophe'),
         ('n', 'm', 'comma', 'period', 'slash'))))

    def __init__(self, **props):
        super().__init__(**props)
        spacer = Gtk.Label()
        spacer.show()
        self.attach(spacer, -4, 0, 4, 1)


class StatusArea(Gtk.Grid):
    def __init__(self, **props):
        super().__init__(**dict(orientation=Gtk.Orientation.HORIZONTAL,
                                **props))
        self.__save_status = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL,
                                      no_show_all=True)
        self.add(self.__save_status)

        save_label = Gtk.Label(_('Saving…'))
        save_label.show()
        self.__save_status.add(save_label)

        save_cancel_button = Gtk.Button.new_with_label(_('Cancel'))
        save_cancel_button.connect('clicked',
                                   lambda b: self.emit('save-cancel-clicked'))
        save_cancel_button.show()
        self.__save_status.add(save_cancel_button)

        self.__cursor_position_label = Gtk.Label(hexpand=True,
                                                 halign=Gtk.Align.END)
        self.add(self.__cursor_position_label)

    def show_save_status(self):
        self.__save_status.show()

    def hide_save_status(self):
        self.__save_status.hide()

    @GObject.Signal
    def save_cancel_clicked(self):
        pass

    def set_cursor_position(self, line, column):
        '''
            Set the (zero-based) line and column number for cursor
            position display.
        '''
        self.__cursor_position_label.set_text(
            _('Line {line}, column {column}')
            .format(line=line+1, column=column+1))

    def pop_out_cursor_position_label(self):
        '''
            Remove the cursor position label from ‘self’ and return it
            so it can be added to another widget.  You should still
            call self.set_cursor_position to update the label.
        '''
        self.remove(self.__cursor_position_label)
        return self.__cursor_position_label

    def pop_in_cursor_position_label(self):
        '''
            Add the cursor position label back to ‘self’.  You should
            remove it from any other container before calling this.
        '''
        self.add(self.__cursor_position_label)


class MenuStack(Gtk.Overlay):
    def __init__(self, **props):
        super().__init__(**props)

        self.__stack = Gtk.Stack(
            transition_type=Gtk.StackTransitionType.OVER_UP_DOWN)
        self.add(self.__stack)

        self.__status_area = StatusArea()
        self.__status_area.show_all()
        self.__stack.add(self.__status_area)

        self.__position_label = None

        self.__right_menu = RMenu()
        self.__right_menu.show_all()
        self.__stack.add(self.__right_menu)
        self.__right_menu.bind_key(_('New'), self.__emitter('new'), 0, 1)
        self.__right_menu.bind_key(_('Close'), self.__emitter('close'), 0, 2)
        self.__right_menu.bind_key(_('Open'), self.__emitter('open'), 0, 3)
        self.__right_menu.bind_key(_('Find'),
                                   lambda b: print('“Find” activated'), 1, 1)
        self.__right_menu.bind_key(_('Save'), self.__emitter('save'), 1, 2)

        self.__left_menu = LMenu()
        self.__left_menu.show_all()
        self.__stack.add(self.__left_menu)
        self.__left_menu.bind_key(_('Undo'),
                                  lambda b: print('“Undo” activated'), 2, 0)
        self.__left_menu.bind_key(_('Cut'), self.__emitter('cut'), 2, 1)
        self.__left_menu.bind_key(_('Copy'), self.__emitter('copy'), 2, 2)
        self.__left_menu.bind_key(_('Paste'), self.__emitter('paste'), 2, 3)
        self.__left_menu.bind_key('↑', self.__emitter('up'), 0, 2)
        self.__left_menu.bind_key('←', self.__emitter('left'), 1, 1)
        self.__left_menu.bind_key('↓', self.__emitter('down'), 1, 2)
        self.__left_menu.bind_key('→', self.__emitter('right'), 1, 3)
        self.__left_menu.bind_key('← Word', self.__emitter('left-word'), 0, 1)
        self.__left_menu.bind_key('→ Word', self.__emitter('right-word'), 0, 3)

    def __emitter(self, action):
        '''
            Create a closure which will will emit the ‘activate’ signal
            with ‘action’ as the signal detail.
        '''
        return lambda _button: self.emit('activate::' + action)

    @GObject.Signal(flags = GObject.SignalFlags.RUN_FIRST
                          | GObject.SignalFlags.DETAILED)
    def activate(self):
        '''
            Emitted when a MenuItem is activated.  The signal detail is
            an identifier for the action to be performed, e.g., 'open'
            or 'save-as'.
        '''
        pass

    @property
    def status_area(self):
        return self.__status_area

    def key_event(self, event):
        '''Handle a key event from the text view'''
        if (event.keyval == Gdk.KEY_Control_L
                and self.__stack.props.visible_child is not self.__left_menu):
            if event.type == Gdk.EventType.KEY_PRESS:
                self.__stack.props.visible_child = self.__right_menu
            else:
                self.__stack.props.visible_child = self.__status_area
            return True
        if (event.keyval == Gdk.KEY_Control_R
                and self.__stack.props.visible_child is not self.__right_menu):
            if event.type == Gdk.EventType.KEY_PRESS:
                self.__stack.props.visible_child = self.__left_menu
                self.__position_label = (
                    self.__status_area.pop_out_cursor_position_label())
                self.__position_label.props.halign = Gtk.Align.END
                self.__position_label.props.valign = Gtk.Align.START
                self.add_overlay(self.__position_label)
            else:
                self.show_status_area()
            return True
        if (self.__stack.props.visible_child is not self.__status_area
                and event.type == Gdk.EventType.KEY_PRESS):
            menu = self.__stack.props.visible_child
            menu.key_press(event.keyval)
            return True
        return False

    def show_status_area(self):
        '''Hide any shown menu and show the status area instead'''
        # FIXME: The cursor position label is momentarily covered by
        # the background of the menu as it slides away.
        if self.__position_label is not None:
            self.remove(self.__position_label)
            self.__status_area.pop_in_cursor_position_label()
            self.__position_label = None
        self.__stack.props.visible_child = self.__status_area


class Editor(Gtk.ApplicationWindow):
    __ROW_TEXT_VIEW = 0
    __ROW_MENU = 1

    def __init__(self, file=None, **props):
        super().__init__(**dict(default_width=640, default_height=480,
                         **props))
        self.__etag = None
        self.__file = file
        self.__saved = True
        self.__close_after_save = False

        grid = Gtk.Grid(orientation=Gtk.Orientation.VERTICAL)
        self.add(grid)
        
        self.__menu_stack = MenuStack()
        grid.attach(self.__menu_stack, 0, self.__ROW_MENU, 1, 1)

        menu_handler_prefix = '_on_menu_'
        for name, object_ in vars(type(self)).items():
            if (name.startswith(menu_handler_prefix)
                    and isinstance(object_, types.FunctionType)):
                signal_name = name[len(menu_handler_prefix):].replace('_', '-')
                self.__menu_stack.connect('activate::' + signal_name,
                                          getattr(self, name))

        tv_scroller = Gtk.ScrolledWindow(shadow_type=Gtk.ShadowType.IN,
                                         expand=True)

        self.__text_view = Gtk.TextView(expand=True)
        tv_scroller.add(self.__text_view)
        self.__text_view.connect('key-press-event',
            lambda text_view, event: self.__menu_stack.key_event(event))
        self.__text_view.connect('key-release-event',
            lambda text_view, event: self.__menu_stack.key_event(event))
        self.__text_view.connect('focus-out-event', self.__on_focus_out_event)
        self.buffer.connect('mark-set', self.__on_mark_set)
        self.__on_cursor_position_changed(self.buffer.get_start_iter())

        if file is None:
            grid.attach(tv_scroller, 0, self.__ROW_TEXT_VIEW, 1, 1)
            self.buffer.connect('changed', self.__on_buffer_changed)
        else:
            hgrid = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
            label = Gtk.Label(_('Loading…'))
            hgrid.add(label)
            cancel_button = Gtk.Button.new_from_stock(Gtk.STOCK_CANCEL)
            hgrid.add(cancel_button)
            grid.attach(hgrid, 0, self.__ROW_TEXT_VIEW, 1, 1)
            hgrid.show_all()

            def callback(file, result, _data=None):
                status, contents, self.__etag = (
                    file.load_contents_finish(result))
                grid.remove(hgrid)
                if status:
                    # Gtk.TextBuffer wants the text without the last newline
                    if contents.endswith(b'\n'):
                        contents = contents[:-1]
                    self.buffer.set_text(str(contents, 'utf-8', 'replace'))
                    tv_scroller.show_all()
                    grid.attach(tv_scroller, 0, self.__ROW_TEXT_VIEW, 1, 1)
                    self.__text_view.grab_focus()
                    self.buffer.place_cursor(self.buffer.get_start_iter())
                    self.buffer.connect('changed', self.__on_buffer_changed)
                else:
                    label.props.label = _('Error!')
                    grid.attach(label, 0, self.__ROW_TEXT_VIEW, 1, 1)

            cancellable = Gio.Cancellable()
            file.load_contents_async(cancellable, callback, None)
            cancel_button.connect('clicked', lambda b: cancellable.cancel())

        grid.show_all()

    @property
    def buffer(self):
        return self.__text_view.props.buffer

    @property
    def filename(self):
        if self.__file is None:
            return None
        else:
            return self.__file.get_path()

    def __on_focus_out_event(self, _text_view, event):
        self.__menu_stack.show_status_area()
        return False

    def __on_mark_set(self, _buffer, location, mark):
        if mark.props.name == 'insert':
            self.__on_cursor_position_changed(location)

    def __on_buffer_changed(self, buffer):
        location = buffer.get_iter_at_mark(buffer.get_insert())
        self.__on_cursor_position_changed(location)
        self.__saved = False

    def __on_cursor_position_changed(self, location):
        self.__menu_stack.status_area.set_cursor_position(
            location.get_line(), location.get_line_offset())

    def _on_menu_new(self, _button):
        if self.props.application is not None:
            self.props.application.activate()

    def do_delete_event(self, _event):
        self._on_menu_close()
        return True

    def _on_menu_close(self, _button=None):
        if not self.__saved:
            DISCARD = 0
            SAVE = 1
            dialog = Gtk.MessageDialog(self,
                                       Gtk.DialogFlags.MODAL,
                                       Gtk.MessageType.QUESTION,
                                       Gtk.ButtonsType.NONE,
                                       _('Save changes to {} before closing?')
                                           .format(self.props.title))
            dialog.add_buttons(_('Close without Saving'), DISCARD,
                               _('Cancel'), Gtk.ResponseType.CANCEL,
                               _('Save'), SAVE)
            dialog.set_default_response(SAVE)
            response = dialog.run()
            dialog.destroy()
            if response in [Gtk.ResponseType.CANCEL,
                            Gtk.ResponseType.DELETE_EVENT]:
                return
            elif response == SAVE:
                self.__close_after_save = True
                self._on_save()
                return
        self.__finish_close()

    def __finish_close(self):
        if self.props.application is not None:
            self.props.application.remove_window(self)
        self.destroy()

    def _on_menu_open(self, _button):
        self.props.application.show_open_dialog(self)

    def _on_menu_save(self, _button=None):
        if self.__file is None:
            chooser = Gtk.FileChooserNative.new(
                _('Save As…'), self, Gtk.FileChooserAction.SAVE, None, None)
            response = chooser.run()
            if response != Gtk.ResponseType.ACCEPT:
                return
            filename = chooser.get_filename()
            self.__file = Gio.File.new_for_path(filename)
        assert self.__file is not None
        assert self.__file.get_path() is not None
        cancellable = Gio.Cancellable()
        cancel_handler = self.__menu_stack.status_area.connect(
            'save-cancel-clicked', lambda b: cancellable.cancel())
        self.__menu_stack.status_area.show_save_status()
        contents = self.buffer.props.text.encode(errors='replace')
        self.__file.replace_contents_async(
            contents, self.__etag, False, Gio.FileCreateFlags.NONE, cancellable,
            lambda file, result, _data=None:
                self.__replace_file_callback(
                    file, result, cancellable, cancel_handler,
                    # We pass “contents” to self.__replace_file_callback
                    # only to keep it alive until writing is finished.
                    contents))

    def __replace_file_callback(self, file, result, cancellable, cancel_handler,
                                _contents):
        try:
            _status, self.__etag = file.replace_contents_finish(result)
        except GLib.Error as error:
            self.__error_on_save(file.get_path(), error)
            return
        file.append_to_async(
            Gio.FileCreateFlags.NONE, GLib.PRIORITY_DEFAULT, cancellable,
            lambda file, result, _data=None:
                self.__append_to_file_callback(file, result, cancellable,
                                              cancel_handler))

    def __append_to_file_callback(self, file, result, cancellable,
                                  cancel_handler):
        try:
            stream = file.append_to_finish(result)
        except GLib.Error as error:
            self.__error_on_save(file.get_path(), error)
            return
        newline = b'\n'
        stream.write_async(
            newline, GLib.PRIORITY_DEFAULT, cancellable,
            lambda stream, result, _data=None:
                self.__write_newline_callback(
                    stream, result, file.get_path(), cancel_handler,
                    # We pass “newline” to self._append_to_file_finish
                    # only to keep it alive until writing is finished.
                    newline))

    def __write_newline_callback(self, stream, result, filename, cancel_handler,
                                 _newline):
        try:
            stream.write_finish(result)
            stream.close()
        except GLib.Error as error:
            self.__error_on_save(filename, error)
            return
        self.__save_terminated(cancel_handler)
        self.__saved = True
        if self.__close_after_save:
            self.__finish_close()
            self.__close_after_save = False

    def __error_on_save(self, filename, error):
        '''Called when there is an error while saving'''
        message = (_('Unable to save file “{filename}”: {message}')
                   .format(filename=filename, message=error.message))
        dialog = Gtk.MessageDialog(self,
                                   Gtk.DialogFlags.DESTROY_WITH_PARENT,
                                   Gtk.MessageType.ERROR,
                                   # XXX: Is ‘Close’ confusing (it
                                   # will not close the file)?
                                   Gtk.ButtonsType.CLOSE, message)
        dialog.run()
        dialog.destroy()
        self.__save_terminated(cancel_handler)

    def __save_terminated(self, cancel_handler):
        '''Called when a save is finished or aborted due to error'''
        self.__menu_stack.status_area.disconnect(cancel_handler)
        self.__menu_stack.status_area.hide_save_status()

    def _on_menu_cut(self, _button):
        clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
        self.buffer.cut_clipboard(clip, True)

    def _on_menu_copy(self, _button):
        clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
        self.buffer.copy_clipboard(clip)

    def _on_menu_paste(self, _button):
        clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
        self.buffer.paste_clipboard(clip, None, True)

    def _on_menu_up(self, _button):
        self.__text_view.emit('move-cursor',
                              Gtk.MovementStep.DISPLAY_LINES, -1, False)

    def _on_menu_down(self, _button):
        self.__text_view.emit('move-cursor',
                              Gtk.MovementStep.DISPLAY_LINES, 1, False)

    def _on_menu_left(self, _button):
        self.__text_view.emit('move-cursor',
                              Gtk.MovementStep.VISUAL_POSITIONS, -1, False)

    def _on_menu_right(self, _button):
        self.__text_view.emit('move-cursor',
                              Gtk.MovementStep.VISUAL_POSITIONS, 1, False)

    def _on_menu_left_word(self, _button):
        self.__text_view.emit('move-cursor',
                              Gtk.MovementStep.WORDS, -1, False)

    def _on_menu_right_word(self, _button):
        self.__text_view.emit('move-cursor',
                              Gtk.MovementStep.WORDS, 1, False)


def home_substitute(filename):
    '''
        Replace home directory with '~'

        If ‘filename’ refers to a file in the user’s home directory,
        return ‘filename’ with the home directory path replaced by '~',
        otherwise return ‘filename’ unmodified.  ‘filename’ should be
        an absolute path.
    '''
    home = GLib.get_home_dir()
    if not home:
        return filename
    if filename.startswith(home):
        return '~' + filename[len(home):]
    else:
        return filename


class Application(Gtk.Application):
    def __init__(self):
        super().__init__(application_id='com.example.Eddy',
                         flags=Gio.ApplicationFlags.HANDLES_OPEN)
        self.__unnamed_window_number = 1

    def do_open(self, files, _n_files, _hint):
        for file in files:
            editor = Editor(file)
            self.add_window(editor)
            editor.show()

    def do_activate(self):
        editor = Editor()
        self.add_window(editor)
        editor.show()

    def do_window_added(self, window):
        Gtk.Application.do_window_added(self, window)
        windows = self.get_windows()
        if window.filename is None:
            window.props.title = _('New File {:d}').format(
                self.__unnamed_window_number)
            self.__unnamed_window_number += 1
        else:
            basenames = self.__get_basenames(window)
            basename = GLib.path_get_basename(window.filename)
            if basename in basenames:
                for w in windows:
                    self.__maybe_set_window_title(w, basename)
            else:
                window.props.title = basename

    @staticmethod
    def __maybe_set_window_title(window, basename):
        if (GLib.path_get_basename(window.filename) == basename):
            window.props.title = home_substitute(window.filename)

    def __get_basenames(self, window):
        '''
            Get the basenames of the filenames of all windows that have
            filenames, except ‘window’.
        '''
        return {GLib.path_get_basename(w.filename) for w in self.get_windows()
                if w is not window and w.filename is not None}

    def do_window_removed(self, window):
        Gtk.Application.do_window_removed(self, window)
        if window.filename is None:
            return
        basename = GLib.path_get_basename(window.filename)
        other_windows = [
            w for w in self.get_windows()
            if w.filename is not None and w is not window
                and GLib.path_get_basename(w.filename) == basename]
        if len(other_windows) == 1:
            other_windows[0].props.title = basename

    def show_open_dialog(self, window):
        # XXX Binding bug?  Should ‘new’ be the default constructor?
        chooser = Gtk.FileChooserNative.new(_('Open File'), window,
                                            Gtk.FileChooserAction.OPEN,
                                            None, None)
        response = chooser.run()
        if response == Gtk.ResponseType.ACCEPT:
            filename = chooser.get_filename()
            file = Gio.File.new_for_path(filename)
            self.open([file], '')



if __name__ == '__main__':
    from os.path import abspath, dirname, isdir, join
    import sys
    # This is the locale directory if we are not installed.
    localedir = abspath(join(dirname(sys.argv[0]), 'locale'))
    if not isdir(localedir):
        localedir = None
    gettext.bindtextdomain('eddy', localedir)
    gettext.textdomain('eddy')
    if Gtk.get_minor_version() < gtk_minor_version:
        dialog = Gtk.MessageDialog(
            None, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR,
            Gtk.ButtonsType.CLOSE,
            _('Eddy requires GTK+ version 3.{} or later').format(
                gtk_minor_version))
        dialog.run()
        sys.exit(1)
    sys.exit(Application().run(sys.argv))
