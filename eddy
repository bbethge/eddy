#! /usr/bin/env python3
"""
Usage:
$ eddy [-h|--help] [file...]

--help  Show this help

Eddy is a graphical text editor based on the idea of keyboard menus:
every (non-application-wide) menu is an image of half of the keyboard
with actions labeling each key.  A menu is shown by holding down a Ctrl
key, and a menu item is activated by pressing the corresponding key.
This should enable the user to keep their hands on the keyboard and not
spend time reaching for the mouse.
"""

import gettext
from gettext import gettext as _
import os
import types
import weakref

import gi
gi.require_version('Gdk', '3.0')
gi.require_version('Gtk', '3.0')
gi.require_version('GtkSource', '3.0')
gtk_minor_version = 14
from gi.repository import GLib, GObject, Gio, Gdk, Pango, Gtk, GtkSource


class MenuItem(Gtk.Button):
    """
    A button on a keyboard-shaped menu.

    A button that has a key associated with it and is activated by that
    key.  It goes inside a Menu.
    """
    def __init__(self, **props):
        super().__init__(**dict(focus_on_click=False, **props))

        self.__grid = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
        self.add(self.__grid)

        self.__label = Gtk.Label(use_underline=True, hexpand=True,
                                 halign=Gtk.Align.START)
        self.__label.props.ellipsize = Pango.EllipsizeMode.END
        self.__grid.add(self.__label)

        self.__keyval_label = Gtk.Label()
        self.__grid.add(self.__keyval_label)

        self.__grid.show_all()

        self.keyval = None
        self.label = None

    @property
    def keyval(self):
        return self.__keyval
    @keyval.setter
    def keyval(self, keyval):
        if keyval is not None:
            kvs = chr(Gdk.keyval_to_unicode(keyval))
            self.__keyval_label.set_markup(
                '<b> '+GLib.markup_escape_text(kvs)+'</b>')
        else:
            self.__keyval_label.props.label = ''

    @property
    def label(self):
        return self.__label.props.label
    @label.setter
    def label(self, label):
        self.__label.props.label = label


class Menu(Gtk.Grid):
    """
    A menu using a keyboard-like layout.

    A panel with several MenuItems arranged in a grid that mimics one
    half of the keyboard.  This will be shown by holding down the Ctrl
    key on the opposite side, and MenuItems can be activated by
    pressing the corresponding key.
    """
    class Side:
        LEFT = 0
        RIGHT = 1

    __keyvals = [
        # Side.LEFT
        list(map(lambda kns: list(map(Gdk.keyval_from_name, kns)),
                 [['q', 'w', 'e', 'r', 't'],
                  ['a', 's', 'd', 'f', 'g'],
                  ['z', 'x', 'c', 'v', 'b']])),
        # Side.RIGHT
        list(map(lambda kns: list(map(Gdk.keyval_from_name, kns)),
                 [['y', 'u', 'i', 'o', 'p', 'bracketleft', 'bracketright'],
                  ['h', 'j', 'k', 'l', 'semicolon', 'apostrophe'],
                  ['n', 'm', 'comma', 'period', 'slash']]))]

    def __init__(self, side, override_widgets=(), **props):
        """
        Create a new menu.

        ‘side’ tells which side of the keyboard to use (Side.LEFT
        or Side.RIGHT).

        override_widgets is a sequence of specifications for widgets
        that will replace some of the buttons.  Each specification is a
        sequence of five things: x, y, width, and height of the region
        to be used, and the widget itself.  The region is given in grid
        coördinates: each key has a width of four and the horizontal
        offset between the first and second rows is one.

        ‘props’ contains GObject properties to be set.
        """
        super().__init__(**dict(row_homogeneous=True, column_homogeneous=True,
                                hexpand=True, **props))
        self.__side = side
        self.__items = {}
        for row, row_contents in enumerate(self.__keyvals[side]):
            for column, keyval in enumerate(row_contents):
                grid_col = self.__key_coörds_to_grid_col(row, column)
                for x, y, width, height, _widget in override_widgets:
                    if x - 3 <= grid_col < x + width and y <= row < y + height:
                        break
                else:
                    item = MenuItem(sensitive=False)
                    item.keyval = keyval
                    item.show()
                    self.attach(item, grid_col, row, 4, 1)
                    self.__items[keyval] = item
        for x, y, width, height, widget in override_widgets:
            self.attach(widget, x, y, width, height)
        spacer = Gtk.Label()
        spacer.show()
        if side == self.Side.LEFT:
            self.attach(spacer, 23, 2, 9, 1)
        else:
            self.attach(spacer, -4, 0, 4, 1)

    def __get_item(self, row, column):
        return self.get_child_at(self.__key_coörds_to_grid_col(row, column),
                                 row)

    @property
    def side(self):
        return self.__side

    def bind_key(self, name, label, callback):
        """
        Bind a key (MenuItem) to a callback.

        Make the MenuItem with keyval name ‘name’ call ‘callback’ when
        it is activated, and label it with ‘label’.
        """ 
        item = self.__items[Gdk.keyval_from_name(name)]
        item.label = label
        item.props.sensitive = True
        item.__handler_id = item.connect('clicked', callback)

    def unbind_key(self, name):
        """Unbind the MenuItem with the given keyval name"""
        item = self.__items[Gdk.keyval_from_name(name)]
        item.disconnect(item.__handler_id)
        item.props.sensitive = False
        item.label = None
        del item.__handler_id

    def do_key_press_event(self, event):
        return self.key_press(event.keyval)

    def do_key_release_event(self, event):
        return self.key_press(event.keyval)

    @staticmethod
    def __key_coörds_to_grid_col(row, column):
        """
        Return the grid column number of a key.

        Given the coördinates of a key, return the leftmost column
        its button occupies in the grid.
        """
        return 4*column + row**2 - row//2

    def key_press(self, keyval):
        """
        Process a key-press event.

        Process a key-press event from another widget that should
        activate one of our buttons.  This is simpler than synthesizing
        a key-press event and emitting it on ‘self’ (read: I couldn’t
        make that work).
        """
        if keyval in self.__items:
            self.__items[keyval].emit('clicked')


class StatusArea(Gtk.Grid):
    def __init__(self, **props):
        super().__init__(**dict(orientation=Gtk.Orientation.HORIZONTAL,
                                **props))
        self.__save_status = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL,
                                      no_show_all=True)
        self.add(self.__save_status)

        save_label = Gtk.Label(_('Saving…'))
        save_label.show()
        self.__save_status.add(save_label)

        save_cancel_button = Gtk.Button.new_with_label(_('Cancel'))
        save_cancel_button.connect('clicked',
                                   lambda b: self.emit('save-cancel-clicked'))
        save_cancel_button.show()
        self.__save_status.add(save_cancel_button)

        self.__cursor_position_label = Gtk.Label(hexpand=True,
                                                 halign=Gtk.Align.END)
        self.add(self.__cursor_position_label)

    def show_save_status(self):
        self.__save_status.show()

    def hide_save_status(self):
        self.__save_status.hide()

    @GObject.Signal
    def save_cancel_clicked(self):
        pass

    def set_cursor_position(self, line, column):
        """
        Update cursor position display.

        Set the (zero-based) line and column number for cursor position
        display.
        """
        self.__cursor_position_label.set_text(
            _('Line {line}, column {column}')
            .format(line=line+1, column=column+1))

    def pop_out_cursor_position_label(self):
        """
        Remove and retrieve the cursor position label.

        Remove the cursor position label from ‘self’ and return it
        so it can be added to another widget.  You should still
        call self.set_cursor_position to update the label.
        """
        self.remove(self.__cursor_position_label)
        return self.__cursor_position_label

    def pop_in_cursor_position_label(self):
        """
        Undo pop_out_cursor_position_label.

        Add the cursor position label back to ‘self’.  It should be
        removed from any other container before calling this.
        """
        self.add(self.__cursor_position_label)


class MenuStack(Gtk.Overlay):
    def __init__(self, **props):
        super().__init__(**props)
        self.__history = []

        self.__stack = Gtk.Stack(
            transition_type=Gtk.StackTransitionType.OVER_UP_DOWN)
        self.add(self.__stack)

        self.__status_area = StatusArea()
        self.__status_area.show_all()
        self.__stack.add(self.__status_area)

        self.__position_label = None

        self.__right_menu = Menu(Menu.Side.RIGHT)
        self.__right_menu.show_all()
        self.__stack.add(self.__right_menu)
        self.__right_menu.bind_key('y', _('Format…'), self._on_format)
        self.__right_menu.bind_key('n', _('New'), self.__emitter('new'))
        self.__right_menu.bind_key('i', _('Close'), self.__emitter('close'))
        self.__right_menu.bind_key('o', _('Open…'), self.__emitter('open'))
        self.__right_menu.bind_key('j', _('Find'),
                                   lambda b: print('“Find” activated'))
        self.__right_menu.bind_key('k', _('Save'), self.__emitter('save'))

        self.__left_menu = Menu(Menu.Side.LEFT)
        self.__left_menu.show_all()
        self.__stack.add(self.__left_menu)
        self.__left_menu.bind_key('z', _('Undo'), self.__emitter('undo'))
        self.__left_menu.bind_key('x', _('Cut'), self.__emitter('cut'))
        self.__left_menu.bind_key('c', _('Copy'), self.__emitter('copy'))
        self.__left_menu.bind_key('v', _('Paste'), self.__emitter('paste'))
        self.__left_menu.bind_key('e', '↑', self.__emitter('up'))
        self.__left_menu.bind_key('s', '←', self.__emitter('left'))
        self.__left_menu.bind_key('d', '↓', self.__emitter('down'))
        self.__left_menu.bind_key('f', '→', self.__emitter('right'))
        self.__left_menu.bind_key('w', '← Word', self.__emitter('left-word'))
        self.__left_menu.bind_key('r', '→ Word', self.__emitter('right-word'))

        self.__format_menu = Menu(Menu.Side.RIGHT)
        self.__format_menu.show_all()
        self.__stack.add(self.__format_menu)
        self.__format_menu.bind_key('bracketright', _('Back'), self._on_back)
        self.__format_menu.bind_key('j', _('Language…'),
                                    lambda b: print('“Language” activated'))
        self.__format_menu.bind_key('k', _('Use Spaces'),
                                    lambda b: print('“Use Spaces” activated'))
        self.__format_menu.bind_key('l', _('Tab Width'),
                                    lambda b: print('“Tab Width” activated'))
        # TODO: Pop up an icon-less Gtk.IconView with source language
        # names when ‘Language…’ is activated, make it stay up when
        # Ctrl is released, focus the icon view, and allow activating
        # the back button with Ctrl-].

    def __emitter(self, action):
        """
        Create a closure to emit the ‘activate’ signal.

        Create a closure which will will emit the ‘activate’ signal
        with ‘action’ as the signal detail.
        """
        return lambda _button: self.emit('activate::' + action)

    def _on_back(self, button):
        self.__stack.props.visible_child = self.__history.pop()

    def _on_format(self, button):
        self.__history.append(self.__stack.props.visible_child)
        self.__stack.props.visible_child = self.__format_menu

    @GObject.Signal(flags = GObject.SignalFlags.RUN_FIRST
                          | GObject.SignalFlags.DETAILED)
    def activate(self):
        """
        Emitted when a MenuItem is activated.

        The signal detail is an identifier for the action to be
        performed, e.g., 'open' or 'save-as'.
        """
        pass

    @property
    def status_area(self):
        return self.__status_area

    def key_event(self, event):
        """Handle a key event from the text view."""
        if (event.keyval == Gdk.KEY_Control_L
                and self.__stack.props.visible_child is not self.__left_menu):
            if event.type == Gdk.EventType.KEY_PRESS:
                self.__stack.props.visible_child = self.__right_menu
            else:
                # We don’t really need self.show_status_area here
                self.__stack.props.visible_child = self.__status_area
            return True
        if (event.keyval == Gdk.KEY_Control_R
                and self.__stack.props.visible_child is not self.__right_menu):
            if event.type == Gdk.EventType.KEY_PRESS:
                self.__stack.props.visible_child = self.__left_menu
                self.__position_label = (
                    self.__status_area.pop_out_cursor_position_label())
                self.__position_label.props.halign = Gtk.Align.END
                self.__position_label.props.valign = Gtk.Align.START
                self.add_overlay(self.__position_label)
            else:
                self.show_status_area()
            return True
        if (self.__stack.props.visible_child is not self.__status_area
                and event.type == Gdk.EventType.KEY_PRESS):
            menu = self.__stack.props.visible_child
            menu.key_press(event.keyval)
            return True
        return False

    def show_status_area(self):
        """Hide any shown menu and show the status area instead."""
        # FIXME: The cursor position label is momentarily covered by
        # the background of the menu as it slides away.
        if self.__position_label is not None:
            self.remove(self.__position_label)
            self.__status_area.pop_in_cursor_position_label()
            self.__position_label = None
        self.__stack.props.visible_child = self.__status_area


class Editor(Gtk.ApplicationWindow):
    __ROW_TEXT_VIEW = 0
    __ROW_MENU = 1

    def __init__(self, file=None, **props):
        super().__init__(**dict(default_width=640, default_height=480,
                         **props))
        self.__etag = None
        self.__file = file
        self.__saved = True
        self.__close_after_save = False

        grid = Gtk.Grid(orientation=Gtk.Orientation.VERTICAL)
        self.add(grid)
        
        self.__menu_stack = MenuStack()
        grid.attach(self.__menu_stack, 0, self.__ROW_MENU, 1, 1)

        menu_handler_prefix = '_on_menu_'
        for name, object_ in vars(type(self)).items():
            if (name.startswith(menu_handler_prefix)
                    and isinstance(object_, types.FunctionType)):
                signal_name = name[len(menu_handler_prefix):].replace('_', '-')
                self.__menu_stack.connect('activate::' + signal_name,
                                          getattr(self, name))

        scroller = Gtk.ScrolledWindow(shadow_type=Gtk.ShadowType.IN,
                                      expand=True)

        self.__source_view = GtkSource.View(expand=True)
        scroller.add(self.__source_view)
        scroller.show_all()
        self.__source_view.connect('key-press-event',
            lambda view, event: self.__menu_stack.key_event(event))
        self.__source_view.connect('key-release-event',
            lambda view, event: self.__menu_stack.key_event(event))
        self.__source_view.connect('focus-out-event', self.__on_focus_out_event)
        self.buffer.connect('mark-set', self.__on_mark_set)
        self.__on_cursor_position_changed(self.buffer.get_start_iter())

        if file is None:
            grid.attach(scroller, 0, self.__ROW_TEXT_VIEW, 1, 1)
            self.buffer.connect('changed', self.__on_buffer_changed)
        else:
            hgrid = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
            label = Gtk.Label(_('Loading…'))
            hgrid.add(label)
            cancel_button = Gtk.Button.new_from_stock(Gtk.STOCK_CANCEL)
            hgrid.add(cancel_button)
            grid.attach(hgrid, 0, self.__ROW_TEXT_VIEW, 1, 1)
            hgrid.show_all()

            cancellable = Gio.Cancellable()
            source_file = GtkSource.File(location=file)
            loader = GtkSource.FileLoader(buffer=self.buffer, file=source_file)
            # TODO: Show progress
            loader.load_async(GLib.PRIORITY_DEFAULT, cancellable, None, None,
                              lambda loader, result:
                                  self.__finish_loading(loader, result,
                                                        grid, hgrid, scroller))
            cancel_button.connect('clicked', lambda b: cancellable.cancel())

        grid.show_all()

    def __finish_loading(self, loader, result, main_grid, progress_grid,
                         scroller):
        try:
            loader.load_finish(result)
        except GLib.Error as error:
            message = (_('Unable to load “{filename}”: {message}')
                       .format(filename=loader.props.location.get_path(),
                               message=error.message))
            dialog = Gtk.MessageDialog(self,
                                       Gtk.DialogFlags.MODAL
                                       | Gtk.DialogFlags.DESTROY_WITH_PARENT,
                                       Gtk.MessageType.ERROR,
                                       Gtk.ButtonsType.CLOSE, message)
            dialog.run()
            dialog.destroy()
        main_grid.remove(progress_grid)
        main_grid.attach(scroller, 0, self.__ROW_TEXT_VIEW, 1, 1)
        self.__source_view.grab_focus()
        self.buffer.place_cursor(self.buffer.get_start_iter())
        self.buffer.connect('changed', self.__on_buffer_changed)

    @property
    def buffer(self):
        return self.__source_view.props.buffer

    @property
    def filename(self):
        if self.__file is None:
            return None
        else:
            return self.__file.get_path()

    def __on_focus_out_event(self, _source_view, event):
        self.__menu_stack.show_status_area()
        return False

    def __on_mark_set(self, _buffer, location, mark):
        if mark.props.name == 'insert':
            self.__on_cursor_position_changed(location)

    def __on_buffer_changed(self, buffer):
        location = buffer.get_iter_at_mark(buffer.get_insert())
        self.__on_cursor_position_changed(location)
        self.__saved = False

    def __on_cursor_position_changed(self, location):
        self.__menu_stack.status_area.set_cursor_position(
            location.get_line(), location.get_line_offset())

    def _on_menu_new(self, _widget):
        if self.props.application is not None:
            self.props.application.activate()

    def do_delete_event(self, _event):
        self._on_menu_close()
        return True

    def _on_menu_close(self, _widget=None):
        if not self.__saved:
            DISCARD = 0
            SAVE = 1
            dialog = Gtk.MessageDialog(self,
                                       Gtk.DialogFlags.MODAL,
                                       Gtk.MessageType.QUESTION,
                                       Gtk.ButtonsType.NONE,
                                       _('Save changes to {} before closing?')
                                           .format(self.props.title))
            dialog.add_buttons(_('Close without Saving'), DISCARD,
                               _('Cancel'), Gtk.ResponseType.CANCEL,
                               _('Save'), SAVE)
            dialog.set_default_response(SAVE)
            response = dialog.run()
            dialog.destroy()
            if response in [Gtk.ResponseType.CANCEL,
                            Gtk.ResponseType.DELETE_EVENT]:
                return
            elif response == SAVE:
                self.__close_after_save = True
                self._on_menu_save()
                return
        self.__finish_close()

    def __finish_close(self):
        """
        Finish closing the window.

        Remove ‘self’ from its application and destroy it.
        """
        if self.props.application is not None:
            self.props.application.remove_window(self)
        self.destroy()

    def _on_menu_open(self, _widget):
        self.props.application.show_open_dialog(self)

    def _on_menu_save(self, _widget=None):
        if self.__file is None:
            chooser = Gtk.FileChooserNative.new(
                _('Save As…'), self, Gtk.FileChooserAction.SAVE, None, None)
            response = chooser.run()
            if response != Gtk.ResponseType.ACCEPT:
                return
            filename = chooser.get_filename()
            self.__file = Gio.File.new_for_path(filename)
        assert self.__file is not None
        assert self.__file.get_path() is not None
        source_file = GtkSource.File(location=self.__file)
        cancellable = Gio.Cancellable()
        cancel_handler = self.__menu_stack.status_area.connect(
            'save-cancel-clicked', lambda b: cancellable.cancel())
        self.__menu_stack.status_area.show_save_status()
        saver = GtkSource.FileSaver(buffer=self.buffer, file=source_file)
        # TODO: Show progress
        saver.save_async(GLib.PRIORITY_DEFAULT, cancellable, None, None,
                         self.__finish_saving, cancel_handler)

    def __finish_saving(self, saver, result, cancel_handler):
        try:
            saver.save_finish(result)
        except GLib.Error as error:
            message = (_('Unable to save file “{filename}”: {message}')
                       .format(filename=saver.props.location.get_path(),
                               message=error.message))
            dialog = Gtk.MessageDialog(self,
                                       Gtk.DialogFlags.DESTROY_WITH_PARENT,
                                       Gtk.MessageType.ERROR,
                                       # XXX: Is ‘Close’ confusing (it
                                       # will not close the file)?
                                       Gtk.ButtonsType.CLOSE, message)
            dialog.run()
            dialog.destroy()
            self.__save_terminated(cancel_handler)
            return
        self.__save_terminated(cancel_handler)
        self.__saved = True
        if self.__close_after_save:
            self.__finish_close()
            self.__close_after_save = False

    def __save_terminated(self, cancel_handler):
        """Called when a save is finished or aborted due to error."""
        self.__menu_stack.status_area.disconnect(cancel_handler)
        self.__menu_stack.status_area.hide_save_status()

    def _on_menu_undo(self, _widget):
        # TODO: Set sensitivity of the button depending on
        # self.buffer.can_undo.
        self.buffer.undo()

    def _on_menu_cut(self, _widget):
        clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
        self.buffer.cut_clipboard(clip, True)

    def _on_menu_copy(self, _widget):
        clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
        self.buffer.copy_clipboard(clip)

    def _on_menu_paste(self, _widget):
        clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
        self.buffer.paste_clipboard(clip, None, True)

    def _on_menu_up(self, _widget):
        self.__source_view.emit('move-cursor',
                                Gtk.MovementStep.DISPLAY_LINES, -1, False)

    def _on_menu_down(self, _widget):
        self.__source_view.emit('move-cursor',
                                Gtk.MovementStep.DISPLAY_LINES, 1, False)

    def _on_menu_left(self, _widget):
        self.__source_view.emit('move-cursor',
                                Gtk.MovementStep.VISUAL_POSITIONS, -1, False)

    def _on_menu_right(self, _widget):
        self.__source_view.emit('move-cursor',
                                Gtk.MovementStep.VISUAL_POSITIONS, 1, False)

    def _on_menu_left_word(self, _widget):
        self.__source_view.emit('move-cursor',
                                Gtk.MovementStep.WORDS, -1, False)

    def _on_menu_right_word(self, _widget):
        self.__source_view.emit('move-cursor',
                                Gtk.MovementStep.WORDS, 1, False)


def home_substitute(filename):
    """
    Replace home directory with '~'.

    If ‘filename’ refers to a file in the user’s home directory, return
    ‘filename’ with the home directory path replaced by '~', otherwise
    return ‘filename’ unmodified.  ‘filename’ should be an absolute
    path.
    """
    home = GLib.get_home_dir()
    if not home:
        return filename
    if filename.startswith(home):
        return '~' + filename[len(home):]
    else:
        return filename


class Application(Gtk.Application):
    def __init__(self):
        super().__init__(application_id='com.example.Eddy',
                         flags=Gio.ApplicationFlags.HANDLES_OPEN)
        self.__unnamed_window_number = 1

    def do_open(self, files, _n_files, _hint):
        for file in files:
            editor = Editor(file)
            self.add_window(editor)
            editor.show()

    def do_activate(self):
        editor = Editor()
        self.add_window(editor)
        editor.show()

    def do_window_added(self, window):
        Gtk.Application.do_window_added(self, window)
        windows = self.get_windows()
        if window.filename is None:
            window.props.title = _('New File {:d}').format(
                self.__unnamed_window_number)
            self.__unnamed_window_number += 1
        else:
            basenames = self.__get_basenames(window)
            basename = GLib.path_get_basename(window.filename)
            if basename in basenames:
                for w in windows:
                    self.__maybe_set_window_title(w, basename)
            else:
                window.props.title = basename

    @staticmethod
    def __maybe_set_window_title(window, basename):
        if (GLib.path_get_basename(window.filename) == basename):
            window.props.title = home_substitute(window.filename)

    def __get_basenames(self, window):
        """
        Return the basenames of the filenames of all windows that have
        filenames, except ‘window’.
        """
        return {GLib.path_get_basename(w.filename) for w in self.get_windows()
                if w is not window and w.filename is not None}

    def do_window_removed(self, window):
        Gtk.Application.do_window_removed(self, window)
        if window.filename is None:
            return
        basename = GLib.path_get_basename(window.filename)
        other_windows = [
            w for w in self.get_windows()
            if w.filename is not None and w is not window
                and GLib.path_get_basename(w.filename) == basename]
        if len(other_windows) == 1:
            other_windows[0].props.title = basename

    def show_open_dialog(self, window):
        chooser = Gtk.FileChooserNative(title=_('Open File'),
                                        transient_for=window,
                                        action=Gtk.FileChooserAction.OPEN)
        response = chooser.run()
        if response == Gtk.ResponseType.ACCEPT:
            filename = chooser.get_filename()
            file = Gio.File.new_for_path(filename)
            self.open([file], '')



if __name__ == '__main__':
    from os.path import abspath, dirname, isdir, join
    import sys
    # This is the locale directory if we are not installed.
    localedir = abspath(join(dirname(sys.argv[0]), 'locale'))
    if not isdir(localedir):
        localedir = None
    gettext.bindtextdomain('eddy', localedir)
    gettext.textdomain('eddy')
    if '-h' in sys.argv or '--help' in sys.argv:
        print(__doc__.strip())
        sys.exit(0)
    if Gtk.get_minor_version() < gtk_minor_version:
        dialog = Gtk.MessageDialog(
            None, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR,
            Gtk.ButtonsType.CLOSE,
            _('Eddy requires GTK+ version 3.{} or later').format(
                gtk_minor_version))
        dialog.run()
        sys.exit(1)
    sys.exit(Application().run(sys.argv))
