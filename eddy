#! /usr/bin/env python3

import gi
gi.require_version('Gdk', '3.0')
gi.require_version('Gtk', '3.0')
from gi.repository import GLib, Gio, Gdk, Gtk


def _(x):
	return x


class MenuItem(Gtk.Button):
	'''
		A button that looks somewhat like a large gtk.ToolButton but
		has a key associated with it and is activated by that key.
		It goes inside a Menu.
	'''
	def __init__(self, label=None, **props):
		super().__init__(focus_on_click=False, **props)

		self.__grid = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
		self.add(self.__grid)

		self.__label = Gtk.Label(
			use_underline=True, hexpand=True,
			halign=Gtk.Align.START)
		self.__grid.add(self.__label)

		self.__keyval_label = Gtk.Label()
		self.__grid.add(self.__keyval_label)

		self.label = label
		self.keyval = None

		self.__grid.show_all()

	@property
	def keyval(self):
		return self.__keyval
	@keyval.setter
	def keyval(self, keyval):
		if keyval is not None:
			kvs = chr(Gdk.keyval_to_unicode(keyval))
			self.__keyval_label.set_markup(
				'<b> '+GLib.markup_escape_text(kvs)+'</b>')
		else:
			self.__keyval_label.props.label = ''

	@property
	def label(self):
		return self.__label.props.label
	@label.setter
	def label(self, label):
		self.__label.props.label = label


class Menu(Gtk.Grid):
	'''
		A panel with several MenuItems arranged in a keyboard-
		like layout that can be activated by the corresponding keys.
	'''
	_keyvals = NotImplemented
	_home_row = NotImplemented

	def __init__(self, **props):
		super().__init__(
			row_homogeneous=False, column_homogeneous=True,
			events=
				Gdk.EventMask.KEY_PRESS_MASK
				| Gdk.EventMask.KEY_RELEASE_MASK,
			**props)
		if type(self) == Menu:
			raise NotImplementedError('Abstract class')
		self.__buttons = {}
		for r, c in self._home_row:
			self.add_item(MenuItem(sensitive=False), r, c)

	def attach_item(self, item, row, column):
		self.attach(item, 4*column + row**2 - row//2, row, 4, 1)

	def add_item(self, item, row, column):
		keyval = self._keyvals[row][column]
		item.keyval = keyval
		item.show()
		if keyval in self.__buttons:
			self.remove(self.__buttons[keyval])
			del self.__buttons[keyval]
		self.attach_item(item, row, column)
		self.__buttons[keyval] = item

	def remove_item(self, row, column):
		keyval = self._keyvals[row][column]
		if keyval in self.__buttons:
			self.remove(self.__buttons[keyval])
			del self.__buttons[keyval]
			if (row, column) in self._home_row:
				b = Gtk.Button(sensitive=False)
				b.show()
				self.attach_item(b, row, column)

	def do_key_press_event(self, event):
		return self.__key_event(event)

	def do_key_release_event(self, event):
		return self.__key_event(event)

	def __key_event(self, event):
		if event.keyval in self.__buttons:
			b = self.__buttons[event.keyval]
			return b.event(key_event_to_button_event(event, b))
		return False


def key_event_to_button_event(key_event, widget):
	be = Gdk.EventButton()
	if key_event.type == Gdk.EventType.KEY_PRESS:
		be.type = Gdk.EventType.BUTTON_PRESS
	elif key_event.type == Gdk.EventType.KEY_RELEASE:
		be.type = Gdk.EventType.BUTTON_RELEASE
	win = widget.props.window
	alloc = widget.get_allocation()
	be.window = win
	be.send_event = key_event.send_event
	be.time = key_event.time
	be.x = alloc.x + alloc.width//2
	be.y = alloc.y + alloc.height//2
	be.state = key_event.state
	be.button = 1
	be.device = widget.get_display().get_default_seat().get_pointer()
	be.x_root, be.y_root = win.get_root_coords(be.x, be.y)
	return be


class LMenu(Menu):
	_keyvals = tuple(map(
		lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
		(
			('q', 'w', 'e', 'r', 't'),
			('a', 's', 'd', 'f', 'g'),
			('z', 'x', 'c', 'v', 'b'))))
	_home_row = (1, 0), (1, 1), (1, 2), (1, 3)


class RMenu(Menu):
	_keyvals = tuple(map(
		lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
		(
			('y', 'u', 'i', 'o', 'p', 'bracketleft', 'bracketright'),
			('h', 'j', 'k', 'l', 'semicolon', 'apostrophe'),
			('n', 'm', 'comma', 'period', 'slash'))))
	_home_row = (1, 1), (1, 2), (1, 3), (1, 4)


class Editor(Gtk.ApplicationWindow):
	def __init__(self, file=None, **props):
		super().__init__(
			default_width=640, default_height=480, **props)

		grid = Gtk.Grid(orientation=Gtk.Orientation.VERTICAL)
		self.add(grid)

		self.__right_menu = RMenu(
			expand=False, halign=Gtk.Align.END, no_show_all=True)
		grid.add(self.__right_menu)
		def add_R(label, r, c, cb):
			item = MenuItem(label)
			self.__right_menu.add_item(item, r, c)
			if cb is not None:
				item.connect('clicked', lambda w: cb())
		add_R(_('New'), 0, 1, self._on_new)
		add_R(_('Close'), 0, 2, self._on_close)
		add_R(_('Find'), 1, 1, None)

		self.__left_menu = LMenu(
			expand=False, halign=Gtk.Align.START, no_show_all=True)
		grid.add(self.__left_menu)
		def add_L(label, r, c, cb):
			item = MenuItem(label)
			self.__left_menu.add_item(item, r, c)
			if cb is not None:
				item.connect('clicked', lambda w: cb())
		add_L(_('Undo'), 2, 0, None)
		add_L(_('Cut'), 2, 1, self._on_cut)
		add_L(_('Copy'), 2, 2, self._on_copy)
		add_L(_('Paste'), 2, 3, self._on_paste)
		add_L('↑', 0, 2, self._on_up)
		add_L('←', 1, 1, self._on_left)
		add_L('↓', 1, 2, self._on_down)
		add_L('→', 1, 3, self._on_right)

		tv_scroller = Gtk.ScrolledWindow(
			shadow_type=Gtk.ShadowType.IN, expand=True)

		self.__text_view = Gtk.TextView(expand=True)
		tv_scroller.add(self.__text_view)
		self.__text_view.connect('key-press-event', self._on_key_event)
		self.__text_view.connect('key-release-event', self._on_key_event)

		if file is None:
			grid.add(tv_scroller)
		else:
			hgrid= Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
			label = Gtk.Label(_('Loading…'))
			hgrid.add(label)
			cancel_button = Gtk.Button.new_from_stock(Gtk.STOCK_CANCEL)
			hgrid.add(cancel_button)
			grid.add(hgrid)
			hgrid.show_all()

			def callback(file, result, _data=None):
				status, contents, _etag = (
					file.load_contents_finish(result))
				grid.remove(hgrid)
				if status:
					buffer = Gtk.TextBuffer()
					buffer.set_text(str(contents, 'utf-8', 'replace'))
					self.__text_view.props.buffer = buffer
					tv_scroller.show_all()
					grid.add(tv_scroller)
				else:
					label.props.label = _('Error!')
					grid.add(label)

			cancellable = Gio.Cancellable()
			file.load_contents_async(cancellable, callback, None)
			cancel_button.connect('clicked', lambda b: cancellable.cancel())

		grid.show_all()

	@property
	def buffer(self):
		return self.__text_view.props.buffer
	@buffer.setter
	def buffer(self, buffer):
		self.text_view.props.buffer = buffer

	def _on_key_event(self, _text_view, event):
		if (event.keyval == Gdk.KEY_Control_L
				and not self.__left_menu.props.visible):
			self.__right_menu.props.visible = (
				event.type == Gdk.EventType.KEY_PRESS)
			return True
		if (event.keyval == Gdk.KEY_Control_R
				and not self.__right_menu.props.visible):
			self.__left_menu.props.visible = (
				event.type == Gdk.EventType.KEY_PRESS)
			return True
		if self.__left_menu.props.visible:
			event = event.copy()
			event.window = self.__left_menu.props.window
			event.state &= ~Gdk.ModifierType.CONTROL_MASK
			return self.__left_menu.event(event)
		if self.__right_menu.props.visible:
			event = event.copy()
			event.window = self.__right_menu.props.window
			event.state &= ~Gdk.ModifierType.CONTROL_MASK
			return self.__right_menu.event(event)
		return False

	def _on_new(self):
		if self.props.application is not None:
			self.props.application.activate()

	def _on_close(self):
		self.hide()
		if self.props.application is not None:
			self.props.application.remove_window(self)

	def _on_cut(self):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.cut_clipboard(clip, True)

	def _on_copy(self):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.copy_clipboard(clip)

	def _on_paste(self):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.paste_clipboard(clip, None, True)

	def _on_up(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.DISPLAY_LINES, -1,
			False)

	def _on_down(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.DISPLAY_LINES, 1,
			False)

	def _on_left(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.VISUAL_POSITIONS, -1,
			False)

	def _on_right(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.VISUAL_POSITIONS, 1,
			False)


class Application(Gtk.Application):
	def __init__(self):
		super().__init__(
			application_id='com.example.Eddy',
			flags=Gio.ApplicationFlags.HANDLES_OPEN)

	def do_open(self, files, _n_files, _hint):
		for file in files:
			editor = Editor(file)
			self.add_window(editor)
			editor.show()

	def do_activate(self):
		editor = Editor()
		self.add_window(editor)
		editor.show()


if __name__ == '__main__':
	import sys
	sys.exit(Application().run(sys.argv))
