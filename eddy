#! /usr/bin/env python3

import weakref

import gi
gi.require_version('Gdk', '3.0')
gi.require_version('Gtk', '3.0')
gtk_minor_version = 14
from gi.repository import GLib, Gio, Gdk, Gtk


def _(x):
	return x


class MenuItem(Gtk.Button):
	'''
		A button that has a key associated with it and is activated by
		that key.  It goes inside a Menu.
	'''
	def __init__(self, **props):
		super().__init__(**dict(focus_on_click=False, **props))

		self.__grid = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
		self.add(self.__grid)

		self.__label = Gtk.Label(
			use_underline=True, hexpand=True,
			halign=Gtk.Align.START)
		self.__grid.add(self.__label)

		self.__keyval_label = Gtk.Label()
		self.__grid.add(self.__keyval_label)

		self.__grid.show_all()

		self.keyval = None
		self.label = None

	@property
	def keyval(self):
		return self.__keyval
	@keyval.setter
	def keyval(self, keyval):
		if keyval is not None:
			kvs = chr(Gdk.keyval_to_unicode(keyval))
			self.__keyval_label.set_markup(
				'<b> '+GLib.markup_escape_text(kvs)+'</b>')
		else:
			self.__keyval_label.props.label = ''

	@property
	def label(self):
		return self.__label.props.label
	@label.setter
	def label(self, label):
		self.__label.props.label = label


class Menu(Gtk.Grid):
	'''
		A panel with several MenuItems arranged in a keyboard-
		like layout that can be activated by the corresponding keys.
	'''
	# A sequence of sequences of keyvals representing the keys used to
	# activate the MenuItems, organized by location.
	_keyvals = NotImplemented

	def __init__(self, **props):
		super().__init__(**dict(
			row_homogeneous=True, column_homogeneous=True,
			hexpand=True, **props))
		if type(self) == Menu:
			raise NotImplementedError('Abstract class')
		self.__items = {}
		for row, row_contents in enumerate(self._keyvals):
			for column in range(len(row_contents)):
				self.__create_item(row, column)

	def __create_item(self, row, column):
		keyval = self._keyvals[row][column]
		item = MenuItem(sensitive=False)
		item.keyval = keyval
		item.show()
		self.attach(
			item,
			self.__key_coörds_to_grid_col(row, column), row, 4, 1)
		self.__items[keyval] = item

	def __get_item(self, row, column):
		return self.get_child_at(
			self.__key_coörds_to_grid_col(row, column), row)

	def bind_key(self, label, callback, row, column):
		item = self.__get_item(row, column)
		item.label = label
		item.props.sensitive = True
		item.__handler_id = item.connect('clicked', callback)

	def unbind_key(self, row, column):
		item = self.__get_item(row, column)
		item.disconnect(item.__handler_id)
		item.props.sensitive = False
		item.label = None
		del item.__handler_id

	def do_key_press_event(self, event):
		return self.key_press(event.keyval)

	def do_key_release_event(self, event):
		return self.key_press(event.keyval)

	@staticmethod
	def __key_coörds_to_grid_col(row, column):
		'''
			Given the coördinates of a key, return the leftmost
			column its button occupies in the grid.
		'''
		return 4*column + row**2 - row//2

	def key_press(self, keyval):
		'''
			Called to indicate a key has been pressed while
			this menu was shown.  This is simpler than
			using event signals.
		'''
		if keyval in self.__items:
			self.__items[keyval].emit('clicked')


class LMenu(Menu):
	_keyvals = tuple(map(
		lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
		(
			('q', 'w', 'e', 'r', 't'),
			('a', 's', 'd', 'f', 'g'),
			('z', 'x', 'c', 'v', 'b'))))

	def __init__(self, **props):
		super().__init__(**props)
		spacer = Gtk.Label()
		spacer.show()
		self.attach(spacer, 23, 2, 9, 1)


class RMenu(Menu):
	_keyvals = tuple(map(
		lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
		(
			('y', 'u', 'i', 'o', 'p', 'bracketleft', 'bracketright'),
			('h', 'j', 'k', 'l', 'semicolon', 'apostrophe'),
			('n', 'm', 'comma', 'period', 'slash'))))

	def __init__(self, **props):
		super().__init__(**props)
		spacer = Gtk.Label()
		spacer.show()
		self.attach(spacer, -4, 0, 4, 1)


class Editor(Gtk.ApplicationWindow):
	__ROW_TEXT_VIEW = 0
	__ROW_MENU = 1

	def __init__(self, application, file=None, **props):
		super().__init__(**dict(
			default_width=640, default_height=480, **props))
		# We avoid a reference cycle with this weakref.  The
		# application should not disappear as long as the window
		# is alive.
		self._application = weakref.proxy(application)
		self._etag = None
		self._file = file

		grid = Gtk.Grid(orientation=Gtk.Orientation.VERTICAL)
		self.add(grid)

		self.__menu_stack = Gtk.Stack()
		self.__menu_stack.props.transition_type = (
			Gtk.StackTransitionType.OVER_UP_DOWN)
		grid.attach(self.__menu_stack, 0, self.__ROW_MENU, 1, 1)

		self.__status_area = Gtk.Grid(
			orientation=Gtk.Orientation.HORIZONTAL)
		self.__menu_stack.add(self.__status_area)

		self.__save_status = Gtk.Grid(
			orientation=Gtk.Orientation.HORIZONTAL,
			no_show_all=True)
		self.__status_area.add(self.__save_status)
		save_label = Gtk.Label(_('Saving…'))
		save_label.show()
		self.__save_status.add(save_label)
		self.__save_cancel_button = Gtk.Button.new_with_label(
			_('Cancel'))
		self.__save_cancel_button.show()
		self.__save_status.add(self.__save_cancel_button)

		self.__cursor_position_label = Gtk.Label()
		self.__status_area.add(self.__cursor_position_label)

		self.__status_area.show_all()

		self.__right_menu = RMenu()
		self.__right_menu.show_all()
		self.__menu_stack.add(self.__right_menu)
		self.__right_menu.bind_key(_('New'), self._on_new, 0, 1)
		self.__right_menu.bind_key(_('Close'), self._on_close, 0, 2)
		self.__right_menu.bind_key(_('Open'), self._on_open, 0, 3)
		self.__right_menu.bind_key(
			_('Find'), lambda b: print('“Find” activated'), 1, 1)
		self.__right_menu.bind_key(_('Save'), self._on_save, 1, 2)

		self.__left_menu = LMenu()
		self.__left_menu.show_all()
		self.__menu_stack.add(self.__left_menu)
		self.__left_menu.bind_key(
			_('Undo'), lambda b: print('“Undo” activated'), 2, 0)
		self.__left_menu.bind_key(_('Cut'), self._on_cut, 2, 1)
		self.__left_menu.bind_key(_('Copy'), self._on_copy, 2, 2)
		self.__left_menu.bind_key(_('Paste'), self._on_paste, 2, 3)
		self.__left_menu.bind_key('↑', self._on_up, 0, 2)
		self.__left_menu.bind_key('←', self._on_left, 1, 1)
		self.__left_menu.bind_key('↓', self._on_down, 1, 2)
		self.__left_menu.bind_key('→', self._on_right, 1, 3)

		tv_scroller = Gtk.ScrolledWindow(
			shadow_type=Gtk.ShadowType.IN, expand=True)

		self.__text_view = Gtk.TextView(expand=True)
		tv_scroller.add(self.__text_view)
		self.__text_view.connect(
			'key-press-event', self._on_key_event)
		self.__text_view.connect(
			'key-release-event', self._on_key_event)
		self.__text_view.connect(
			'focus-out-event', self._on_focus_out_event)
		tv_buffer = self.__text_view.get_buffer()
		tv_buffer.connect('mark-set', self._on_mark_set)
		tv_buffer.connect('changed', self._on_buffer_changed)
		self._on_cursor_position_changed(tv_buffer.get_start_iter())

		if file is None:
			grid.attach(
				tv_scroller, 0, self.__ROW_TEXT_VIEW, 1, 1)
		else:
			hgrid= Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
			label = Gtk.Label(_('Loading…'))
			hgrid.add(label)
			cancel_button = Gtk.Button.new_from_stock(Gtk.STOCK_CANCEL)
			hgrid.add(cancel_button)
			grid.attach(hgrid, 0, self.__ROW_TEXT_VIEW, 1, 1)
			hgrid.show_all()

			def callback(file, result, _data=None):
				status, contents, self._etag = (
					file.load_contents_finish(result))
				grid.remove(hgrid)
				if status:
					buffer = Gtk.TextBuffer()
					buffer.set_text(str(contents, 'utf-8', 'replace'))
					self.__text_view.props.buffer = buffer
					tv_scroller.show_all()
					grid.attach(
						tv_scroller, 0,
						self.__ROW_TEXT_VIEW, 1, 1)
					self.__text_view.grab_focus()
					buffer = self.__text_view.get_buffer()
					buffer.place_cursor(buffer.get_start_iter())
				else:
					label.props.label = _('Error!')
					grid.attach(
						label, 0,
						self.__ROW_TEXT_VIEW, 1, 1)

			cancellable = Gio.Cancellable()
			file.load_contents_async(cancellable, callback, None)
			cancel_button.connect('clicked', lambda b: cancellable.cancel())

		grid.show_all()

	@property
	def buffer(self):
		return self.__text_view.props.buffer
	@buffer.setter
	def buffer(self, buffer):
		self.text_view.props.buffer = buffer

	def _on_key_event(self, _text_view, event):
		if (event.keyval == Gdk.KEY_Control_L
				and self.__menu_stack.props.visible_child
					is not self.__left_menu):
			if event.type == Gdk.EventType.KEY_PRESS:
				self.__menu_stack.props.visible_child = (
					self.__right_menu)
			else:
				self.__menu_stack.props.visible_child = (
					self.__status_area)
			return True
		if (event.keyval == Gdk.KEY_Control_R
				and self.__menu_stack.props.visible_child
					is not self.__right_menu):
			if event.type == Gdk.EventType.KEY_PRESS:
				self.__menu_stack.props.visible_child = (
					self.__left_menu)
			else:
				self.__menu_stack.props.visible_child = (
					self.__status_area)
			return True
		if (self.__menu_stack.props.visible_child
				is not self.__status_area
				and event.type == Gdk.EventType.KEY_PRESS):
			menu = self.__menu_stack.props.visible_child
			menu.key_press(event.keyval)
			return True
		return False

	def _on_focus_out_event(self, _text_view, event):
		self.__menu_stack.props.visible_child = self.__status_area
		return False

	def _on_mark_set(self, _buffer, location, mark):
		if mark.props.name == 'insert':
			self._on_cursor_position_changed(location)

	def _on_buffer_changed(self, buffer):
		location = buffer.get_iter_at_mark(buffer.get_insert())
		self._on_cursor_position_changed(location)
		
	def _on_cursor_position_changed(self, location):
		line = location.get_line() + 1
		column = location.get_line_offset() + 1
		self.__cursor_position_label.set_text(
			_('Line {line}, column {column}').format(
				line=line, column=column))

	def _on_new(self, _button):
		if self.props.application is not None:
			self.props.application.activate()

	def _on_close(self, _button):
		self.hide()
		if self.props.application is not None:
			self.props.application.remove_window(self)

	def _on_open(self, _button):
		self._application.show_open_dialog(self)

	def _on_save(self, _button):
		if self._file is None:
			chooser = Gtk.FileChooserNative.new(
				_('Save As…'), self,
				Gtk.FileChooserAction.SAVE, None, None)
			response = chooser.run()
			if response != Gtk.ResponseType.ACCEPT:
				return
			filename = chooser.get_filename()
			self._file = Gio.File.new_for_path(filename)
		assert self._file is not None
		assert self._file.get_path() is not None
		cancellable = Gio.Cancellable()
		cancel_handler = self.__save_cancel_button.connect(
			'clicked', lambda b: cancellable.cancel())
		self.__save_status.show()
		contents = self.buffer.props.text.encode(errors='replace')
		self._file.replace_contents_async(
			contents=contents, etag=self._etag, make_backup=False,
			flags=Gio.FileCreateFlags.NONE,
			cancellable=cancellable,
			callback = lambda f, r, d=None:
				self.__save_file_callback(
					f, r, d, cancel_handler))

	def __save_file_callback(self, file, result, _data, cancel_handler):
		try:
			_status, self._etag = (
				file.replace_contents_finish(result))
		except GLib.Error as err:
			message = _(
				'Unable to save file “{filename}”: '
				'{message}') .format(
					filename=file.get_path(),
					message=err.message)
			dialog = Gtk.MessageDialog(
				self, Gtk.DialogFlags.DESTROY_WITH_PARENT,
				Gtk.MessageType.ERROR,
				# XXX: Is ‘Close’ confusing (it
				# will not close the file)?
				Gtk.ButtonsType.CLOSE, message)
			dialog.run()
			dialog.destroy()
		self.__save_cancel_button.disconnect(cancel_handler)
		self.__save_status.hide()

	def _on_cut(self, _button):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.cut_clipboard(clip, True)

	def _on_copy(self, _button):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.copy_clipboard(clip)

	def _on_paste(self, _button):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.paste_clipboard(clip, None, True)

	def _on_up(self, _button):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.DISPLAY_LINES, -1,
			False)

	def _on_down(self, _button):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.DISPLAY_LINES, 1,
			False)

	def _on_left(self, _button):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.VISUAL_POSITIONS, -1,
			False)

	def _on_right(self, _button):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.VISUAL_POSITIONS, 1,
			False)


class Application(Gtk.Application):
	def __init__(self):
		super().__init__(
			application_id='com.example.Eddy',
			flags=Gio.ApplicationFlags.HANDLES_OPEN)

	def do_open(self, files, _n_files, _hint):
		for file in files:
			editor = Editor(self, file)
			self.add_window(editor)
			editor.show()

	def do_activate(self):
		editor = Editor(self)
		self.add_window(editor)
		editor.show()

	def show_open_dialog(self, window):
		# XXX Binding bug?  Should ‘new’ be the default constructor?
		chooser = Gtk.FileChooserNative.new(
			_('Open File'), window, Gtk.FileChooserAction.OPEN,
			None, None)
		response = chooser.run()
		if response == Gtk.ResponseType.ACCEPT:
			filename = chooser.get_filename()
			file = Gio.File.new_for_path(filename)
			self.open([file], '')



if __name__ == '__main__':
	import sys
	if Gtk.get_minor_version() < gtk_minor_version:
		dialog = Gtk.MessageDialog(
			None, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR,
			Gtk.ButtonsType.CLOSE,
			_('Eddy requires GTK+ version 3.{} or later').format(
				gtk_minor_version))
		dialog.run()
		sys.exit(1)
	sys.exit(Application().run(sys.argv))
