#! /usr/bin/env python3

import gi
gi.require_version('Gdk', '3.0')
gi.require_version('Gtk', '3.0')
from gi.repository import GLib, Gio, Gdk, Gtk


def _(x):
	return x


class MenuItem(Gtk.Button):
	'''
		A button that looks somewhat like a large gtk.ToolButton but
		has a key associated with it and is activated by that key.
		It goes inside a Menu.
	'''
	def __init__(self, **props):
		super().__init__(focus_on_click=False, **props)

		self.__grid = Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
		self.add(self.__grid)

		self.__label = Gtk.Label(
			use_underline=True, hexpand=True,
			halign=Gtk.Align.START)
		self.__grid.add(self.__label)

		self.__keyval_label = Gtk.Label()
		self.__grid.add(self.__keyval_label)

		self.__grid.show_all()

		self.keyval = None
		self.label = None

	@property
	def keyval(self):
		return self.__keyval
	@keyval.setter
	def keyval(self, keyval):
		if keyval is not None:
			kvs = chr(Gdk.keyval_to_unicode(keyval))
			self.__keyval_label.set_markup(
				'<b> '+GLib.markup_escape_text(kvs)+'</b>')
		else:
			self.__keyval_label.props.label = ''

	@property
	def label(self):
		return self.__label.props.label
	@label.setter
	def label(self, label):
		self.__label.props.label = label


class Menu(Gtk.Grid):
	'''
		A panel with several MenuItems arranged in a keyboard-
		like layout that can be activated by the corresponding keys.
	'''
	_keyvals = NotImplemented

	def __init__(self, **props):
		super().__init__(
			row_homogeneous=True, column_homogeneous=True,
			events=
				Gdk.EventMask.KEY_PRESS_MASK
				| Gdk.EventMask.KEY_RELEASE_MASK,
			**props)
		if type(self) == Menu:
			raise NotImplementedError('Abstract class')
		self.__items = {}
		for row, row_contents in enumerate(self._keyvals):
			for column in range(len(row_contents)):
				self.__create_item(row, column)

	def __create_item(self, row, column):
		keyval = self._keyvals[row][column]
		item = MenuItem(sensitive=False)
		item.keyval = keyval
		item.show()
		self.attach(
			item,
			self.__key_coörds_to_grid_col(row, column), row, 4, 1)
		self.__items[keyval] = item

	def __get_item(self, row, column):
		return self.get_child_at(
			self.__key_coörds_to_grid_col(row, column), row)

	def bind_key(self, label, callback, row, column):
		item = self.__get_item(row, column)
		item.label = label
		item.props.sensitive = True
		item.__handler_id = item.connect('clicked', callback)

	def unbind_key(self, row, column):
		item = self.__get_item(row, column)
		item.disconnect(item.__handler_id)
		item.props.sensitive = False
		item.label = None
		del item.__handler_id

	def do_key_press_event(self, event):
		return self.__key_event(event)

	def do_key_release_event(self, event):
		return self.__key_event(event)

	@staticmethod
	def __key_coörds_to_grid_col(row, column):
		'''
			Given the coördinates of a key, return the leftmost
			column its button occupies in the grid.
		'''
		return 4*column + row**2 - row//2

	def __key_event(self, event):
		if event.keyval in self.__items:
			item = self.__items[event.keyval]
			return item.event(
				self.__key_event_to_button_event(event, item))
		return False

	@staticmethod
	def __key_event_to_button_event(key_event, widget):
		be = Gdk.EventButton()
		if key_event.type == Gdk.EventType.KEY_PRESS:
			be.type = Gdk.EventType.BUTTON_PRESS
		elif key_event.type == Gdk.EventType.KEY_RELEASE:
			be.type = Gdk.EventType.BUTTON_RELEASE
		win = widget.props.window
		alloc = widget.get_allocation()
		be.window = win
		be.send_event = key_event.send_event
		be.time = key_event.time
		be.x = alloc.x + alloc.width//2
		be.y = alloc.y + alloc.height//2
		be.state = key_event.state
		be.button = 1
		be.device = widget.get_display().get_default_seat().get_pointer()
		be.x_root, be.y_root = win.get_root_coords(be.x, be.y)
		return be


class LMenu(Menu):
	_keyvals = tuple(map(
		lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
		(
			('q', 'w', 'e', 'r', 't'),
			('a', 's', 'd', 'f', 'g'),
			('z', 'x', 'c', 'v', 'b'))))


class RMenu(Menu):
	_keyvals = tuple(map(
		lambda kns: tuple(map(Gdk.keyval_from_name, kns)),
		(
			('y', 'u', 'i', 'o', 'p', 'bracketleft', 'bracketright'),
			('h', 'j', 'k', 'l', 'semicolon', 'apostrophe'),
			('n', 'm', 'comma', 'period', 'slash'))))


class Editor(Gtk.ApplicationWindow):
	def __init__(self, file=None, **props):
		super().__init__(
			default_width=640, default_height=480, **props)

		grid = Gtk.Grid(orientation=Gtk.Orientation.VERTICAL)
		self.add(grid)

		self.__right_menu = RMenu(
			expand=False, halign=Gtk.Align.END, no_show_all=True)
		grid.add(self.__right_menu)
		self.__right_menu.bind_key(_('New'), self._on_new, 0, 1)
		self.__right_menu.bind_key(_('Close'), self._on_close, 0, 2)
		self.__right_menu.bind_key(
			_('Find'), lambda: print('“Find” activated'), 1, 1)

		self.__left_menu = LMenu(
			expand=False, halign=Gtk.Align.START, no_show_all=True)
		grid.add(self.__left_menu)
		self.__left_menu.bind_key(
			_('Undo'), lambda: print('“Undo” activated'), 2, 0)
		self.__left_menu.bind_key(_('Cut'), self._on_cut, 2, 1)
		self.__left_menu.bind_key(_('Copy'), self._on_copy, 2, 2)
		self.__left_menu.bind_key(_('Paste'), self._on_paste, 2, 3)
		self.__left_menu.bind_key('↑', self._on_up, 0, 2)
		self.__left_menu.bind_key('←', self._on_left, 1, 1)
		self.__left_menu.bind_key('↓', self._on_down, 1, 2)
		self.__left_menu.bind_key('→', self._on_right, 1, 3)

		tv_scroller = Gtk.ScrolledWindow(
			shadow_type=Gtk.ShadowType.IN, expand=True)

		self.__text_view = Gtk.TextView(expand=True)
		tv_scroller.add(self.__text_view)
		self.__text_view.connect('key-press-event', self._on_key_event)
		self.__text_view.connect('key-release-event', self._on_key_event)

		if file is None:
			grid.add(tv_scroller)
		else:
			hgrid= Gtk.Grid(orientation=Gtk.Orientation.HORIZONTAL)
			label = Gtk.Label(_('Loading…'))
			hgrid.add(label)
			cancel_button = Gtk.Button.new_from_stock(Gtk.STOCK_CANCEL)
			hgrid.add(cancel_button)
			grid.add(hgrid)
			hgrid.show_all()

			def callback(file, result, _data=None):
				status, contents, _etag = (
					file.load_contents_finish(result))
				grid.remove(hgrid)
				if status:
					buffer = Gtk.TextBuffer()
					buffer.set_text(str(contents, 'utf-8', 'replace'))
					self.__text_view.props.buffer = buffer
					tv_scroller.show_all()
					grid.add(tv_scroller)
				else:
					label.props.label = _('Error!')
					grid.add(label)

			cancellable = Gio.Cancellable()
			file.load_contents_async(cancellable, callback, None)
			cancel_button.connect('clicked', lambda b: cancellable.cancel())

		grid.show_all()

	@property
	def buffer(self):
		return self.__text_view.props.buffer
	@buffer.setter
	def buffer(self, buffer):
		self.text_view.props.buffer = buffer

	def _on_key_event(self, _text_view, event):
		if (event.keyval == Gdk.KEY_Control_L
				and not self.__left_menu.props.visible):
			self.__right_menu.props.visible = (
				event.type == Gdk.EventType.KEY_PRESS)
			return True
		if (event.keyval == Gdk.KEY_Control_R
				and not self.__right_menu.props.visible):
			self.__left_menu.props.visible = (
				event.type == Gdk.EventType.KEY_PRESS)
			return True
		if self.__left_menu.props.visible:
			event = event.copy()
			event.window = self.__left_menu.props.window
			event.state &= ~Gdk.ModifierType.CONTROL_MASK
			return self.__left_menu.event(event)
		if self.__right_menu.props.visible:
			event = event.copy()
			event.window = self.__right_menu.props.window
			event.state &= ~Gdk.ModifierType.CONTROL_MASK
			return self.__right_menu.event(event)
		return False

	def _on_new(self):
		if self.props.application is not None:
			self.props.application.activate()

	def _on_close(self):
		self.hide()
		if self.props.application is not None:
			self.props.application.remove_window(self)

	def _on_cut(self):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.cut_clipboard(clip, True)

	def _on_copy(self):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.copy_clipboard(clip)

	def _on_paste(self):
		clip = self.get_clipboard(Gdk.SELECTION_CLIPBOARD)
		self.buffer.paste_clipboard(clip, None, True)

	def _on_up(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.DISPLAY_LINES, -1,
			False)

	def _on_down(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.DISPLAY_LINES, 1,
			False)

	def _on_left(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.VISUAL_POSITIONS, -1,
			False)

	def _on_right(self):
		self.__text_view.emit(
			'move-cursor', Gtk.MovementStep.VISUAL_POSITIONS, 1,
			False)


class Application(Gtk.Application):
	def __init__(self):
		super().__init__(
			application_id='com.example.Eddy',
			flags=Gio.ApplicationFlags.HANDLES_OPEN)

	def do_open(self, files, _n_files, _hint):
		for file in files:
			editor = Editor(file)
			self.add_window(editor)
			editor.show()

	def do_activate(self):
		editor = Editor()
		self.add_window(editor)
		editor.show()


if __name__ == '__main__':
	import sys
	sys.exit(Application().run(sys.argv))
